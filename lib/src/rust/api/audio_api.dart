// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'audio_api.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// Check if native audio is available on this platform.
bool audioIsNativeAvailable() =>
    RustLib.instance.api.crateApiAudioApiAudioIsNativeAvailable();

/// Initialize the audio engine.
void audioInit() => RustLib.instance.api.crateApiAudioApiAudioInit();

/// Check if the audio engine is initialized.
bool audioIsInitialized() =>
    RustLib.instance.api.crateApiAudioApiAudioIsInitialized();

/// Play an audio file.
Future<void> audioPlay({required String path}) =>
    RustLib.instance.api.crateApiAudioApiAudioPlay(path: path);

/// Queue the next track for gapless playback.
Future<void> audioQueueNext({required String path}) =>
    RustLib.instance.api.crateApiAudioApiAudioQueueNext(path: path);

/// Pause playback.
Future<void> audioPause() => RustLib.instance.api.crateApiAudioApiAudioPause();

/// Resume playback after pause.
Future<void> audioResume() =>
    RustLib.instance.api.crateApiAudioApiAudioResume();

/// Stop playback completely.
Future<void> audioStop() => RustLib.instance.api.crateApiAudioApiAudioStop();

/// Seek to a position in the current track.
Future<void> audioSeek({required double positionSecs}) =>
    RustLib.instance.api.crateApiAudioApiAudioSeek(positionSecs: positionSecs);

/// Set the playback volume.
Future<void> audioSetVolume({required double volume}) =>
    RustLib.instance.api.crateApiAudioApiAudioSetVolume(volume: volume);

/// Configure crossfade settings.
Future<void> audioSetCrossfade({
  required bool enabled,
  required double durationSecs,
}) => RustLib.instance.api.crateApiAudioApiAudioSetCrossfade(
  enabled: enabled,
  durationSecs: durationSecs,
);

/// Skip to the next queued track.
Future<void> audioSkipToNext() =>
    RustLib.instance.api.crateApiAudioApiAudioSkipToNext();

/// Set the playback speed.
Future<void> audioSetPlaybackSpeed({required double speed}) =>
    RustLib.instance.api.crateApiAudioApiAudioSetPlaybackSpeed(speed: speed);

/// Get the current playback speed.
double? audioGetPlaybackSpeed() =>
    RustLib.instance.api.crateApiAudioApiAudioGetPlaybackSpeed();

/// Get the current playback state.
String audioGetState() => RustLib.instance.api.crateApiAudioApiAudioGetState();

/// Get the current playback progress.
AudioProgress? audioGetProgress() =>
    RustLib.instance.api.crateApiAudioApiAudioGetProgress();

/// Poll for audio events (non-blocking).
AudioEventType? audioPollEvent() =>
    RustLib.instance.api.crateApiAudioApiAudioPollEvent();

/// Set the crossfade curve type.
Future<void> audioSetCrossfadeCurve({required CrossfadeCurveType curve}) =>
    RustLib.instance.api.crateApiAudioApiAudioSetCrossfadeCurve(curve: curve);

/// Get the audio engine's sample rate.
int? audioGetSampleRate() =>
    RustLib.instance.api.crateApiAudioApiAudioGetSampleRate();

/// Get the current track path.
String? audioGetCurrentPath() =>
    RustLib.instance.api.crateApiAudioApiAudioGetCurrentPath();

/// Get the number of audio channels.
BigInt? audioGetChannels() =>
    RustLib.instance.api.crateApiAudioApiAudioGetChannels();

/// Shutdown the audio engine.
Future<void> audioShutdown() =>
    RustLib.instance.api.crateApiAudioApiAudioShutdown();

@freezed
sealed class AudioEventType with _$AudioEventType {
  const AudioEventType._();

  const factory AudioEventType.stateChanged({required String state}) =
      AudioEventType_StateChanged;
  const factory AudioEventType.progress({
    required double positionSecs,
    double? durationSecs,
    required double bufferLevel,
  }) = AudioEventType_Progress;
  const factory AudioEventType.trackEnded({required String path}) =
      AudioEventType_TrackEnded;
  const factory AudioEventType.crossfadeStarted({
    required String fromPath,
    required String toPath,
  }) = AudioEventType_CrossfadeStarted;
  const factory AudioEventType.error({required String message}) =
      AudioEventType_Error;
  const factory AudioEventType.nextTrackReady({required String path}) =
      AudioEventType_NextTrackReady;
}

/// Progress information returned to Dart.
class AudioProgress {
  /// Current position in seconds
  final double positionSecs;

  /// Total duration in seconds (if known)
  final double? durationSecs;

  /// Buffer fill level (0.0 to 1.0)
  final double bufferLevel;

  const AudioProgress({
    required this.positionSecs,
    this.durationSecs,
    required this.bufferLevel,
  });

  @override
  int get hashCode =>
      positionSecs.hashCode ^ durationSecs.hashCode ^ bufferLevel.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AudioProgress &&
          runtimeType == other.runtimeType &&
          positionSecs == other.positionSecs &&
          durationSecs == other.durationSecs &&
          bufferLevel == other.bufferLevel;
}

/// Crossfade curve type for Dart.
enum CrossfadeCurveType { equalPower, linear, squareRoot, sCurve }
